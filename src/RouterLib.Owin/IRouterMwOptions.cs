using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace RouterLib.Owin
{
    // Owin function definition
    using AppFunc = Func<IDictionary<string, object>, Task>;
    // original owin context, routing results, returns a task
    using ProcessResponseFunc = Func<IDictionary<string, object>, RoutingResultBase, Task>;
    // original owin context, Error, Exception generated by router, Next in OwinPipeline returns a task
    using ExceptionFunc = Func<IDictionary<string, object>, Exception, Func<IDictionary<string, object>, Task>, Task>;
    // Owin original context, Next in Owin pipeline, returns a task
    using NoRouteFoundFunc = Func<IDictionary<string, object>, Func<IDictionary<string, object>, Task>, Task>;

    public interface IRouterMwOptions
    {
        /// <summary>
        /// Use this to process response. This is required!
        /// </summary>
        ProcessResponseFunc OnProcessResponse { get; set; }

        /// <summary>
        /// Use this to handle exeptions thrown in the router.
        /// </summary>
        ExceptionFunc OnException { get; set; }

        /// <summary>
        /// Use this to handle scenario when not rute was found.
        /// </summary>
        NoRouteFoundFunc OnNoRouteFound { get; set; }

        /// <summary>
        /// Validate configuration options
        /// </summary>
        void Validate();

        /// <summary>
        /// Handles routing logic
        /// </summary>
        /// <param name="Next">Next middleware</param>
        /// <param name="environment">Owin environment</param>
        /// <returns></returns>
        Task ProcessOwinRequestAsync(AppFunc Next, IDictionary<string, object> environment);
    }
}
